# 狼行天下

## 项目介绍

### 项目目的

1，项目的总体安排；

2，项目的重点：

    1，本项目的重点不是去制作一个完整旅游点评项目，而是了解整个旅游点评项目各个流程和需求，对实际项目开发有一个较为深刻的理解；
    
    2，掌握项目中的一些重要的第三方工具/框架；比如bootstrap；uploadify;ueditor;等的使用；
    
    3，掌握提升自我价值的知识点；比如redis,mongodb,elasticsearch，mybatis-plus
    
    4，掌握如何从0到1开发项目。

3，项目的学习方法：

	1，深入学习和理解项目的需求，和一个产品的设计理念；
	
	2，这个项项目，重点不要纠结于细节的代码实现，要从更大的范围去理解一个项目/产品的开发过程；
	
	3，理解项目中的相关业务流程，学会自己去阅读第三方开发文档等（分享/第三方登录/短信发送）；
	
	4，从原理上掌握更高级的工具的使用，重点是要理解，什么时候需要用到这些东西，和使用这些东西的基本方式；

### 项目需求

### 项目演示

### 技术路线

我们在做架构的时候并没有讲到SSH，SSM。这些东西不叫架构.做叫做技术路线.在做架构的时候根本就没必要在意用得是什么语言,或者什么框架。

项目技术路线:

1，数据库：mysql + mongodb + elasticsearch +Redis （缓存）

2，持久化层：spring-data ; mybatis-plus

3，业务层：Springboot；

4，Web：SpringMVC；

5，前端：

       管理后台：jQuery+Bootstrap3
    
       前端展示：vue +jquery + css；



6：开发模式

       管理后台：以前传统模式(类似crm)
    
       前端展示：前后端分离方式

### 项目搭建

- 项目拆分

	- trip-website
	- trip-website-api
	- trip-mgrsite

- maven项目结构分析

- 项目组成结构

	- 父项目

		- wolf2w

		  1：对子项目进行版本管理

		  2：对值项目的依赖进行管理

	- 核心组件

		- trip-core

		  业务核心逻辑

		  

		  domain/repository/service/query/util等

	- 管理后端

		- trip-mgrsite

		  维护前端展示数据

		  

		  controller/模板页面

	- PC前端数据接口

		- trip-website-api

		  前端展示数据请求接口，返回纯json格式数据

	- PC前端

		- trip-website

		  发起请求，请求trip-website-api接口，获取数据并展示数据，此项目为纯静态页面

- 代码实现



```java
//一开始在website-api启动后可能会报这个错，那是因为在website-api启动，一般在哪一个先启动，那么它就会默认使用这子项目下的properties，而四要素的配置是放在trip-core子项目下的，所以还要再把它改名，变成不冲突，但改名后默认就不会帮你加，所以还需要另起一个包放配置类，再用@PropertySource关联一下再启动才不会报错
Description:

Failed to configure a DataSource: 'url' attribute is not specified and no embedded datasource could be configured.
```







## 注册/登录

### 用户注册



```java
package cn.wolfcode.wolf2w.domain;

import com.baomidou.mybatisplus.annotation.TableName;
import com.fasterxml.jackson.annotation.JsonIgnore;
import lombok.Getter;
import lombok.Setter;


@Setter
@Getter
@TableName("userinfo")
public class UserInfo extends BaseDomain{

    public static final int GENDER_SECRET = 0; //保密
    public static final int GENDER_MALE = 1;   //男
    public static final int GENDER_FEMALE = 2;  //女
    public static final int STATE_NORMAL = 0;  //正常
    public static final int STATE_DISABLE = 1;  //冻结
    private String nickname;  //昵称
    private String phone;  //手机
    private String email;  //邮箱



    @JsonIgnore
    private String password; //密码
    private Integer gender = GENDER_SECRET; //性别
    private Integer level = 0;  //用户级别
    private String city;  //所在城市
    private String headImgUrl; //头像
    private String info;  //个性签名
    private Integer state = STATE_NORMAL; //状态

}
```



```java
package cn.wolfcode.wolf2w.domain;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import lombok.Getter;
import lombok.Setter;
import java.io.Serializable;

@Getter
@Setter
public  abstract  class BaseDomain implements Serializable {

    @TableId(type= IdType.AUTO)
    protected Long id;

}
```



```java
package cn.wolfcode.wolf2w.mapper;

import cn.wolfcode.wolf2w.domain.UserInfo;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import org.springframework.stereotype.Repository;


/**
 * mybatis-plus mapper编写规则:
 * 1:自定义一个mapper接口
 * 2:接口继承BaseMapper接口
 * 3:BaseMapper接口明确指定要操作的实体对象泛型: Employee
 */

@Repository
public interface UserInfoMapper extends BaseMapper<UserInfo> {
    
}
```



```java
package cn.wolfcode.wolf2w.service;

import cn.wolfcode.wolf2w.domain.UserInfo;
import com.baomidou.mybatisplus.extension.service.IService;


/**
 * mybatis-plus service 层接口定义规则:
 * 1>自定义一个接口:IUserInfoService
 * 2>继承一个通用接口:IService
 * 3>指定一泛型: 要操作实体对象: UserInfo
 */

public interface IUserInfoService extends IService<UserInfo> {

}

```



```java
package cn.wolfcode.wolf2w.service.impl;

import cn.wolfcode.wolf2w.domain.UserInfo;
import cn.wolfcode.wolf2w.mapper.UserInfoMapper;
import cn.wolfcode.wolf2w.service.IUserInfoService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;

/**
 *  自定义mybatis-plus 服务层接口实现类
 *  1> 自定义接口 UserInfoServiceImpl
 *  2> 实现自定义接口 IUserInfoService
 *  3> 继承通用接口IService实现类 ServiceImpl
 *     指定2个泛型: 1. 操作实体类mapper接口  2.操作实体对象类型:UserInfo
 */

public class UserInfoServiceImpl extends ServiceImpl<UserInfoMapper, UserInfo> implements IUserInfoService {

}
```





- 手机号校验

  - 格式校验
  - 唯一性校验

  	- 跨域配置

  	  步骤1：implements WebMvcConfigurer

  	  

  	  步骤2：

  	  //跨域访问

  	  在website-api这子项目里建一个config包，放跨问的配置类
  	  
  	  ```java
  	  package cn.wolfcode.wolf2w.config;
  	  
  	  import org.springframework.context.annotation.Bean;
  	  import org.springframework.context.annotation.Configuration;
  	  import org.springframework.web.servlet.config.annotation.CorsRegistry;
  	  import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
  	  
  	  @Configuration
  	  public class WebConfig {
  	  
  	      @Bean
  	      public WebMvcConfigurer corsConfigurer() {
  	  
  	          return new WebMvcConfigurer() {
  	              @Override
  	              //重写父类提供的跨域请求处理的接口
  	              public void addCorsMappings(CorsRegistry registry) {
  	                  //添加映射路径
  	                  registry.addMapping("/**")
  	                          //放行哪些原始域
  	                          .allowedOriginPatterns("*")
  	                          //是否发送Cookie信息
  	                          .allowCredentials(true)
  	                          //放行哪些原始域(请求方式)
  	                          .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
  	                          //放行哪些原始域(头部信息)
  	                          .allowedHeaders("*")
  	                          //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）
  	                          .exposedHeaders("Header1", "Header2");
  	              }
  	          };
  	      }
  	  }
  	  
  	  ```

- 逻辑实现

  - 参数校验

    

    ```java
    /**
    
     * 参数断言工具类
    
     */
    
    public class AssertUtil {
    
    /**
    
     * 判断传入的参数是否有值
     * @param value
     * @param msg
     * @return
     */
    
    public static void hasLength(String value,String msg){
    
        if(value == null || "".equals(value.trim())){
            throw new LogicException(msg);
        }
    }
    
    /**
    
     * 两次输入的值必须一致
     * @param v1
     * @param v2
     * @param msg
     */
    
    public static void isEquals(String v1, String v2, String msg) {
    
        if(v1 == null || v2 == null){
            throw new LogicException("判断的参数不允许为null");
        }
    
        if(!v1.equals(v2)){
            throw new LogicException(msg);
        }
      }
    }
    ```
    
    
    
  - 自定义异常
  
    
  
    
  
    ```java
    /**
    
     * 自定义的异常
     * 1:用于区分系统异常与主动抛出的一样
     */
    public class LogicException extends RuntimeException{
    
        public LogicException(String msg){
            super(msg);
            }
    }
    ```
    
    
  
- 短信验证码

	- 页面倒计时
	- 验证码存储

		- 验证操作分析
		- 存储方案选择

			- session
			- redis

		- 代码实现

			- 引入redis
			- redis代码结构
			- redis的key设计

	- 用户注册完善(加入短信验证)
	- 真实短信发送

		- 短信原理分析
		
		- 短信网关
		
		  京东万象：https://wx.jdcloud.com/api-66
		
		  中国网建：http://sms.webchinese.com.cn/
		
		  阿里短信
		
		- 短信api测试
		
		- 用户注册(加入短信验证)
		
		- 技术延伸
		
		  不要仅限于短信发送
	
- 细节优化

  - 统一异常处理

    

    ```java
    package cn.wolfcode.wolf2w.advice;
    
    
    
    import cn.wolfcode.wolf2w.exception.LogicException;
    
    import cn.wolfcode.wolf2w.util.JsonResult;
    
    import org.springframework.web.bind.annotation.ControllerAdvice;
    
    import org.springframework.web.bind.annotation.ExceptionHandler;
    
    import org.springframework.web.bind.annotation.ResponseBody;
    
    
    
    import javax.servlet.http.HttpServletRequest;
    
    import javax.servlet.http.HttpServletResponse;
    
    import javax.servlet.http.HttpSession;
    
    
    
    /**
    
    *通用异常处理类
    
    *ControllerAdvice  controller类功能增强注解, 动态代理controller类实现一些额外功能
    
     *
    
    *请求进入controller映射方法之前做功能增强: 经典用法:日期格式化
    
    *请求进入controller映射方法之后做功能增强: 经典用法:统一异常处理
    
     */
    
    @ControllerAdvice
    
    public class CommonExceptionHandler {
    
    
    
    //这个方法定义的跟映射方法操作一样
    
    @ExceptionHandler(LogicException.class)
    
    @ResponseBody
    
    public Object logicExp(Exception e, HttpServletResponse resp) {
    
        e.printStackTrace();
    
        resp.setContentType("application/json;charset=utf-8");
    
        return JsonResult.error(JsonResult.CODE_ERROR_PARAM, e.getMessage(), null);
    
    }
    
    
    @ExceptionHandler(RuntimeException.class)
    
    @ResponseBody
    
    public Object  runTimeExp(Exception e, HttpServletResponse resp) {
    
        e.printStackTrace();
    
        resp.setContentType("application/json;charset=utf-8");
    
        return JsonResult.defaultError();
    
    }
    
    
    }
    ```

    

  - Redis key重设计

    

    ```java
    /**
    
    *redis key管理
    
     */
    
    @Getter
    
    public enum  RedisKeys{
    
    
    //短信验证码
    
    VERIFY_CODE("verify_code", 60 * 5L),
    
    //登录token
    
    LOGIN_TOKEN("user_login_token", 60 * 30L);
    
    
    private String prefix;
    
    private Long time;
    
    
    private RedisKeys(String prefix, Long time){
    
        this.prefix = prefix;
    
        this.time = time;
    
    }
    
    public String join(String ...keys){
    
        StringBuilder sb = new StringBuilder();
    
        sb.append(prefix);
    
        for (String key : keys) {
    
            sb.append(":").append(key);
    
        }
    
        return sb.toString();
    
    }
    
    
    }
    ```

    

    

    

### 用户登录

- 互联网项目登录

	- 登录逻辑分析(传统)
	- 登录逻辑分析(互联网)
	- 代码实现

- 登录控制

	- 请求统一拦截

	  定义：CheckLoginInterceptor

	  

	  配置：CheckLoginInterceptor

	  

	  在主配置类中implements WebMvcConfigurer

	   @Override

	      public void addInterceptors(InterceptorRegistry registry) {
	        
	          registry.addInterceptor(checkLoginInterceptor())
	        
	                  .addPathPatterns("/**");
	        
	      }

	  

	- 请求区分拦截

		- @RequireLogin

## 目的地

### 后端

- 区域管理

  - 模型

    - 区域

      

      ```java
      package cn.wolfcode.wolf2w.domain;
      
      
      
      import com.alibaba.fastjson.JSON;
      
      import com.baomidou.mybatisplus.annotation.TableField;
      
      import com.baomidou.mybatisplus.annotation.TableName;
      
      import lombok.Getter;
      
      import lombok.Setter;
      
      import org.springframework.util.StringUtils;
      
      
      
      import java.util.ArrayList;
      
      import java.util.HashMap;
      
      import java.util.List;
      
      import java.util.Map;
      
      
      
      /**
      
      *区域
      
       */
      
      @Setter
      
      @Getter
      
      @TableName("region")
      
      public class Region extends BaseDomain {
      
      public static final int STATE_HOT = 1;
      
      public static final int STATE_NORMAL = 0;
          
      private String name;        //地区名
      
      private String sn;          //地区编码
      
      private String refIds;     //关联的id， 多个以，隔开
          
          
      private Integer ishot = STATE_NORMAL;         //是否为热点
      
      private Integer seq;   //序号
      
      private String info;  //简介
      
      public List<Long> parseRefIds(){
      
          List<Long> ids = new ArrayList<>();
      
          if(StringUtils.hasLength(refIds)){
      
              String[] split = refIds.split(",");
      
              if(split != null && split.length > 0){
      
                  for (int i = 0;i <split.length; i++) {
      
                      ids.add(Long.parseLong(split[i]));
      
                  }
      
              }
      
          }
      
         return ids;
      
      }
      
      public String getJsonString(){
      
          Map<String, Object> map = new HashMap<>();
      
          map.put("id",id);
      
          map.put("name",name);
      
          map.put("sn",sn);
      
          map.put("refIds",getRefIds());
      
          map.put("ishot",ishot);
      
          map.put("seq",seq);
      
          map.put("info",info);
      
          return JSON.toJSONString(map);
      
      }
      
      
      }
      ```

      

    - 目的地

      

      ```JAVA
      package cn.wolfcode.wolf2w.domain;
      
      
      
      import com.alibaba.fastjson.JSON;
      
      import com.baomidou.mybatisplus.annotation.TableField;
      
      import com.baomidou.mybatisplus.annotation.TableName;
      
      import lombok.Getter;
      
      import lombok.Setter;
      
      import java.util.ArrayList;
      
      import java.util.HashMap;
      
      import java.util.List;
      
      import java.util.Map;
      
      
      
      /**
      
      *目的地(行政地区：国家/省份/城市)
      
       */
      
      @Setter
      
      @Getter
      
      @TableName("destination")
      
      public class Destination extends BaseDomain {
      
      
      private String name;        //名称
      
      private String english;  //英文名
      
      private Long parentId; //上级目的地
      
      private String parentName;  //上级目的名
      
      private String info;    //简介
      
      private String coverUrl;
      
      
      @TableField(exist = false)
      
      private List<Destination> children = new ArrayList<>()
      
      public String getJsonString(){
      
          Map<String, Object> map = new HashMap<>();
      
          map.put("id", super.getId());
      
          map.put("info", this.info);
      
          return JSON.toJSONString(map);
      
      	}
      
      }
      ```

      

  - 列表

  	- 分页

  - 添加

    - 多选下拉框

      ```js
    	//数据复原
      
    	$("#editForm").clearForm(true);
      
    	$('#refIds').selectpicker('val', '');
    	```
    	
    	- bootstrap-select

  - 编辑

    - 多选下拉框回显

      ```js
      //回显
      
      $('#refIds').selectpicker('val', refIds);
      
      $('#refIds').selectpicker('refresh');
      ```

  - 查看
  - 热门

  	- 设置
  	- 取消

  - 删除

- 目的地管理

	- 列表

		- 高级查询
		- 导航吐司

	- 编辑

		- 设置简介【拓展】

### 前端

- 目的地切换

## 旅游攻略

### 后端

- 攻略分类

  

  ```java
  package cn.wolfcode.wolf2w.domain;
  
  
  
  import com.alibaba.fastjson.JSON;
  
  import com.baomidou.mybatisplus.annotation.TableName;
  
  import lombok.Getter;
  
  import lombok.Setter;
  
  import java.util.HashMap;
  
  import java.util.Map;
  
  
  
  /**
  
   * 攻略主题
  
   */
  
  @Setter
  
  @Getter
  
  @TableName("strategy_theme")
  
  public class StrategyTheme extends BaseDomain {
  
  
  public static final int STATE_NORMAL = 0; //正常
    
  public static final int STATE_DISABLE = 1; //禁用
  
  private String name;  //主题名称
    
  private Integer state = STATE_NORMAL; //主题状态
  
  private Integer seq; //序号
    
  public String getStateDisplay(){
    
      return state == STATE_NORMAL ? "正常" : "禁用";
    
  }
    
  public String getJsonString(){
    
      Map<String, Object> map = new HashMap<>();
    
      map.put("id",id);
    
      map.put("name",name);
    
      map.put("state",state);
    
      map.put("seq",seq);
    
      return JSON.toJSONString(map);
    
  }
  
  }
  ```

  

  - 列表
  - 添加
  - 编辑

- 攻略主题

  

  ```java
  /**
  
  *攻略主题
  
   */
  
  @Setter
  
  @Getter
  
  @Document("strategy_theme")
  
  public class StrategyTheme extends BaseDomain {
  
  public static final int STATE_NORMAL = 0; //正常
    
  public static final int STATE_DISABLE = 1; //禁用
  
  private String name;  //主题名称
    
  private int state = STATE_NORMAL; //主题状态
  
  private int sequence; //序号
    
  public String getStateDisplay(){
    
      return state == STATE_NORMAL ? "正常" : "禁用";
    
  }
    
  public String getJsonString(){
    
      Map<String, Object> map = new HashMap<>();
    
      map.put("id",id);
    
      map.put("name",name);
    
      map.put("state",state);
    
      map.put("sequence",sequence);
    
      return JSON.toJSONString(map);
    
  }
  
  }
  ```

  

  - 列表
  - 添加
  - 编辑

- 攻略明细

  

  ```java
  package cn.wolfcode.wolf2w.domain;
  
  import com.baomidou.mybatisplus.annotation.TableField;
  
  import com.baomidou.mybatisplus.annotation.TableName;
  
  import lombok.Getter;
  
  import lombok.Setter;
  
  import lombok.ToString;
  
  import java.util.Date;
  
  
  
  /**
  
  *攻略
  
   */
  
  @Setter
  
  @Getter
  
  @TableName("strategy")
  
  public class Strategy extends BaseDomain {
  
  public static final int  ABROAD_NO = 0;  //国内
  
  public static final int  ABROAD_YES = 1;  //国外
  
  public static final int STATE_NORMAL = 0;  //带发布
  
  public static final int STATE_PUBLISH = 1; //发布
  
  private Long destId;  //关联的目的地
  
  private String destName;
  
  private Long themeId; //关联主题
  
  private String themeName;
  
  private Long catalogId;  //关联的分类
  
  private String catalogName;
  
  private String title;  //标题
  
  private String subTitle; //副标题
  
  private String summary;  //内容摘要
  
  private String coverUrl;  //封面
  
  private Date createTime;  //创建时间
  
  private Integer isabroad = ABROAD_NO;  //是否是国外
  
  private Integer viewnum;  //点击数
  
  private Integer replynum;  //攻略评论数
  
  private Integer favornum; //收藏数
  
  private Integer sharenum; //分享数
  
  private Integer thumbsupnum; //点赞个数
  
  private Integer state = STATE_NORMAL;  //状态
  
  @TableField(exist = false)
  
  private StrategyContent content; //攻略内容
  
  public String getStateDisplay(){
  
      return state == STATE_PUBLISH ? "发布" :"待发布";
  
  	}
  }
  ```

  

  - 列表
  - 添加

    - 封面上传

    	- uploadfive
    	- 阿里OSS
    	- 代码实现

    - 分组下拉框

      - 页面
      - 数据准备

        

        ```java
        /**
        
        *分组下拉框的vo对象
        
         */
        
        @Setter
        
        @Getter
        
        public class CatalogVO {
        
        private String destName;
        
        private List<StrategyCatalog> catalogList = new ArrayList<>();
        
        }
        ```

        

        

        

        select dest_name, GROUP_CONCAT(name) names, GROUP_CONCAT(id) ids

        from strategy_catalog group by dest_name

        

        

        ----------------------------------------------------------------------------------------------------------------------------------

        

        ```java
        
         @Override
        public List<CatalogVO> queryGroupCatalog() {
        
            List<CatalogVO> vos = new ArrayList<>();
        
            //1:查询数据
        
            QueryWrapper<StrategyCatalog> wrapper = new QueryWrapper<>();
        
            wrapper.select("dest_name, GROUP_CONCAT(name) names, GROUP_CONCAT(id) ids ")
        
                   .groupBy("dest_name");
        
            List<Map<String, Object>> list = super.listMaps(wrapper);
        
            //2：封装vo对象
        
            //dest_name  names  ids  ----> vo
        
            for (Map<String, Object> map : list) {
        
                CatalogVO vo = new CatalogVO();
        
                vo.setDestName(map.get("dest_name").toString());  //目的地名字
        
                String names = map.get("names").toString();
        
                String ids = map.get("ids").toString();
        
                List<StrategyCatalog> catalogList = this.parseCatalog(names, ids);
        
                vo.setCatalogList(catalogList);
        
                vos.add(vo);
        
            }
        
            return vos;
        
        }
        
        private List<StrategyCatalog> parseCatalog(String names, String ids) {
        
            List<StrategyCatalog> list = new ArrayList<>();
        
            String[] ns = names.split(","); //截取name
        
            String[] is = ids.split(",");//截取id
        
            if(ns.length > 0){
        
                for (int i = 0; i <ns.length; i++) {
        
                    String name = ns[i];
        
                    String id = is[i];
        
                    if(!StringUtils.hasLength(name)){
        
                        continue;
        
                    }
        
                    StrategyCatalog catalog = new StrategyCatalog();
        
                    catalog.setName(name);
        
                    catalog.setId(Long.parseLong(id));
        
                    list.add(catalog);
        
                }
        
            }
        
            return list;
        
        }
        ```

        

        

    - 富文本编辑框

      - ckeditor

        

        ```java
        @RequestMapping("/uploadImg_ck")
        
        @ResponseBody
        
        public Map<String, Object> upload(MultipartFile upload, String module){
        
            Map<String, Object> map = new HashMap<String, Object>();
        
            String imagePath= null;
        
            if(upload != null && upload.getSize() > 0){
        
                try {
        
                    //图片保存, 返回路径
        
                    imagePath =  UploadUtil.uploadAli(upload);
        
                    //表示保存成功
        
                    map.put("uploaded", 1);
        
                    map.put("url",imagePath);
                }catch (Exception e){
        
                    e.printStackTrace();
        
                    map.put("uploaded", 0);
        
                    Map<String, Object> mm = new HashMap<String, Object>();
        
                    mm.put("message",e.getMessage() );
        
                    map.put("error", mm);
        
                }
        
            }
        
            return map;
        
        }
        ```
        
        
        

    - 代码实现

  - 编辑

  	- 回显

### 前端

- 目的地明细中-攻略

	- 面包屑(toast)
	- 攻略概况

		- 攻略分类
		- 攻略明细

	- 攻略点击前3
	- 查看详细
	- 查看所有

- 攻略首页

  - 攻略排行

    

    

    ```java
    package cn.wolfcode.wolf2w.domain;
    
    
    
    import com.baomidou.mybatisplus.annotation.TableField;
    
    import com.baomidou.mybatisplus.annotation.TableName;
    
    import lombok.Getter;
    
    import lombok.Setter;
    
    
    
    import java.util.Date;
    
    
    
    /**
    
    *攻略统计表
    
     */
    
    @Setter
    
    @Getter
    
    @TableName("strategy_rank")
    
    public class StrategyRank extends  BaseDomain{
    
    public static final Integer TYPE_ABROAD = 1;  //国外
      
    public static final Integer TYPE_CHINA = 2;   //国内
      
    public static final Integer TYPE_HOT = 3;     //热门
    
    private Long destId;  //目的地id
      
    private String destName; //目的地名称
      
    private Long strategyId; //攻略id
      
    private String strategyTitle; //攻略标题
      
    private Integer type; //排行类型
      
    private Date statisTime; //归档统计时间
      
    private Long statisnum; //归档统计数
    
    }
    ```

    

    

  - 攻略条件

    

    

    ```java
    package cn.wolfcode.wolf2w.domain;
    
    import com.baomidou.mybatisplus.annotation.TableName;
    import lombok.Getter;
    import lombok.Setter;
    import java.util.Date;
    
    
    
    /**
    
    *攻略条件统计表
    
     */
    
    @Setter
    
    @Getter
    
    @TableName("strategy_condition")
    
    public class StrategyCondition extends  BaseDomain{
    
    public static final Integer TYPE_ABROAD = 1;  //国外
      
    public static final Integer TYPE_CHINA = 2;   //国内
      
    public static final Integer TYPE_THEME = 3;     //热门
    
    private String name;
      
    private Integer count; //个数
      
    private Long refid; //关联id
      
    private Integer type; //条件类型
      
    private Date statisTime; //归档统计时间
    
    }
    ```

    

    

    - 条件查询

      

      ```java
      @Setter
      
      @Getter
      
      public class StrategyQuery extends  QueryObject{
      
      private Long destId;
        
      private Long themeId;
        
      private Integer type = -1;
        
      private String typeName;
        
      private Long refid;
        
      private String orderBy;
      
      }
      ```
      
      
      
      

  - 主题推荐【拓展】

    

    

    ```java
    @Setter
    
    @Getter
    
    public class ThemeVO {
    
    private String  themeName;
    
    private List<DestVO> dests = new ArrayList<>();
    
    }
    ```

    

    ```java
    @Setter
    
    @Getter
    
    @NoArgsConstructor
    
    @AllArgsConstructor
    
    public class DestVO {
    
    private Long id;
    
    private String name;
    
    }
    ```

    

    ----------------------------------------------------

    

    ```java
    @Override
    
    public List<ThemeVO> queryThemeCommand() {
    
        List<ThemeVO> list = new ArrayList<>();
    
        QueryWrapper<Strategy> wrapper = WrapperUtil.queryWrapper(Strategy.class)
    
                .select("theme_name, count(id) count, GROUP_CONCAT(dest_id) ids,  GROUP_CONCAT(dest_name) names")
    
                .groupBy("theme_name")
    
                .orderByDesc("count");
    
        List<Map<String, Object>> mapList = super.listMaps(wrapper);
    
        List<String> ds = new ArrayList<>();
    
        for (Map<String, Object> map : mapList) {
    
            ThemeVO vo = new ThemeVO();
    
            vo.setThemeName(map.get("theme_name").toString());
    
            List<DestVO> dests = new ArrayList<>();
    
            String[] ids = map.get("ids").toString().split(",");
    
            String[] names = map.get("names").toString().split(",");
    
            for(int i = 0; i < names.length; i++){
    
                if(ds.contains(names[i])){
    
                    continue;
    
                }else{
    
                    DestVO dest = new DestVO(Long.valueOf(ids[i]), names[i]);
    
                    dests.add(dest);
    
                    ds.add(names[i]);
    
                }
    
            }
    
            ds.clear();
    
            vo.setDests(dests);
    
            list.add(vo);
    
        }
    
        return list;
    
    }
    ```
    
    
    
    
    

## 旅游日记

### 后端

- 列表

  ```java
  package cn.wolfcode.wolf2w.domain;
  
  
  import com.baomidou.mybatisplus.annotation.TableField;
  import com.baomidou.mybatisplus.annotation.TableName;
  import lombok.Getter;
  import lombok.Setter;
  import org.springframework.data.annotation.Transient;
  import org.springframework.format.annotation.DateTimeFormat;
  import java.util.Date;
  
  
  
  /**
  
  *游记
  
   */
  
  @Setter
  @Getter
  @TableName("travel")
  public class Travel extends BaseDomain {
  
  public static final int STATE_NORMAL = 0;  //草稿
    
  public static final int STATE_WAITING = 1;  //待发布(审核中)
    
  public static final int STATE_RELEASE = 2;  //审核通过
    
  public static final int STATE_REJECT = 3;  //拒绝
  
  public static final int ISPUBLIC_NO = 0;
    
  public static final int ISPUBLIC_YES = 1;
  
  private Long destId;  //目的地
  
  private String destName;  //目的地
  
  private Long authorId;  //作者id
    
  @TableField(exist = false)
    
  private UserInfo author;
  
  private String title;  //标题
  
  private String summary;//概要
  
  private String coverUrl; //封面
  
  @DateTimeFormat(pattern = "yyyy-MM-dd")
    
  private Date travelTime; //旅游时间
  
  private Integer avgConsume; //人均消费
  
  private Integer day;  //旅游天数
  
  private Integer person;  //和谁旅游
  
  private Date createTime; //创建时间
  
  private Date releaseTime; //发布时间
  
  private Date lastUpdateTime; //最新更新时间内
  
  private Integer ispublic=ISPUBLIC_NO; //是否发布
  
  private Integer viewnum;  //点击/阅读数
  
  private Integer replynum; //回复数
  
  private Integer favornum;//收藏数
  
  private Integer sharenum;//分享数
  
  private Integer thumbsupnum;//点赞数
  
  private Integer state = STATE_NORMAL;//游记状态
  
  @TableField(exist = false)
    
  private TravelContent content;  //游记内容
  
  public String getStateDisplay(){
    
      if (state ==STATE_NORMAL ){
    
          return "编辑中";
    
      }else if(state ==STATE_WAITING ){
    
          return "待发布";
    
      }else if(state ==STATE_RELEASE ){
    
          return "已发布";
    
      }else if(state ==STATE_REJECT ){
    
          return "已拒绝";
    
      }
    
      return "";
    
  }
  
  public String getPersonDisplay(){
    
     if (person == 1){
    
         return "一个人";
    
     }else if (person == 2){
    
         return "情侣/夫妻";
    
     }else if (person == 3){
    
         return "带孩子";
    
     }else if (person == 4){
    
         return "家庭出游";
    
     }else if (person == 5){
    
         return "和朋友";
    
     }else if (person == 6){
    
         return "和同学";
    
     }else if (person == 7){
    
         return "其它";
    
     }
    
     return "其它";
    
  }
  
  }
  ```

- 查看
- 审核

### 前端

- 目的地明细中-游记

  - 带范围条件查询

    

    

    ```java
    @Setter
    
    @Getter
    
    public class TravelQuery extends  QueryObject{
    
    private Long destId;
      
    private String orderBy="create_time";  //排序
      
    private int travelTimeType = -1; //旅游时间
      
    private int consumeType = -1; //人均消费
      
    private int dayType = -1; //·旅游天数
    
    }
    ```

    

    

    

    

    -------------------------------------------------------

    

    

    ```java
    package cn.wolfcode.wolf2w.query;
    
    import lombok.Getter;
    
    import java.util.HashMap;
    
    import java.util.Map;
    
    
    
    @Getter
    
    public class TravelCondition {
    
    //旅游时间
      
    public static final Map<Integer, TravelCondition> TIMEMAP = new HashMap<>();
      
    //旅游天数
      
    public static final Map<Integer, TravelCondition> DAYMAP = new HashMap<>();
      
    //旅游人均
      
    public static final Map<Integer, TravelCondition> CONSUMEMAP = new HashMap<>();
      
    static {
    
        TIMEMAP.put(1, new TravelCondition(1, 2));
      
        TIMEMAP.put(2, new TravelCondition(3, 4));
      
        TIMEMAP.put(3, new TravelCondition(5, 6));
      
        TIMEMAP.put(4, new TravelCondition(7, 8));
      
        TIMEMAP.put(5, new TravelCondition(9, 10));
      
        TIMEMAP.put(6, new TravelCondition(11, 12));
    
        DAYMAP.put(1, new TravelCondition(0, 3));
      
        DAYMAP.put(2, new TravelCondition(4, 7));
      
        DAYMAP.put(3, new TravelCondition(8, 14));
      
        DAYMAP.put(4, new TravelCondition(15, Integer.MAX_VALUE));
    
        CONSUMEMAP.put(1, new TravelCondition(0, 999));
      
        CONSUMEMAP.put(2, new TravelCondition(1000, 6000));
      
        CONSUMEMAP.put(3, new TravelCondition(6001, 20000));
      
        CONSUMEMAP.put(4, new TravelCondition(20001, Integer.MAX_VALUE));
      
    }
      
    private int min;
      
    private int max;
      
    public TravelCondition(int min, int max){
      
        this.max = max;
      
        this.min = min;
      
    }
    
    }
    ```

    

    

- 游记首页
- 【拓展】游记添加/编辑

  实现功能： 封面上传， 百度富文本编辑器整合

  

  

  

  1：从参考项目中拷贝：

     UploadController 到 api的controller包中

     UMEditorUploader 到 api 的util包

  

  2: 在TravelController 类上面添加下面代码

  

  ```java
  //上传图片
    
  @RequestMapping("/contentImage")
    
  public String uploadUEImage(MultipartFile upfile, HttpServletRequest request) throws Exception{
    
      UMEditorUploader up = new UMEditorUploader(request);
    
      String[] fileType = {".gif" , ".png" , ".jpg" , ".jpeg" , ".bmp"};
    
      up.setAllowFiles(fileType);
    
      up.setMaxSize(10000); //单位KB
    
      up.upload(upfile);
  
      String callback = request.getParameter("callback");
    
      String result = "{\"name\":\""+ up.getFileName() +"\", \"originalName\": \""+ up.getOriginalName() +"\", \"size\": "+ up.getSize()
    
              +", \"state\": \""+ up.getState() +"\", \"type\": \""+ up.getType() +"\", \"url\": \""+ up.getUrl() +"\"}";
    
      result = result.replaceAll( "\\\\", "\\\\" );
    
      if(callback == null ){
    
          return result ;
    
      }else{
    
          return "<script>"+ callback +"(" + result + ")</script>";
    
      }
    
  }
  ```

  

- 【拓展】 添加游记时间没登录时给提示
- 【拓展】只有当前登录用户是游记作者时, 才可以显示编辑按钮

  查询detail是关联查询作者id 跟登录的用户id对比

  一致时,显示, 不一致时不显示

## 内容评论

### 前端

- 评论类型

	- 朋友圈式
	- 盖楼式

- 攻略评论

  

  ```java
  /**
  
  *攻略评论
  
   */
  
  @Setter
  
  @Getter
  
  @Document("strategy_comment")
  
  @ToString
  
  public class StrategyComment extends BaseDomain {
  
  private String strategyId;  //攻略(明细)id
    
  private String strategyTitle; //攻略标题
    
  private String userId;    //用户id
    
  private String nickname;  //用户名
    
  private String city;
    
  private int level;
    
  private String headImgUrl;     //头像
    
  private Date createTime;    //创建时间
    
  private String content;      //评论内容
    
  private int thumbupnum;     //点赞数
    
  private List<String> thumbuplist = new ArrayList<>();
  
  }
  ```

  

  - _class属性排除

    ```java
    //mongodb 去除_class属性
      
    @Bean
      
    public MappingMongoConverter mappingMongoConverter(MongoDatabaseFactory factory, MongoMappingContext context, BeanFactory beanFactory) {
      
        DbRefResolver dbRefResolver = new DefaultDbRefResolver(factory);
      
        MappingMongoConverter mappingConverter = new MappingMongoConverter(dbRefResolver, context);
      
        try {   mappingConverter.setCustomConversions(beanFactory.getBean(CustomConversions.class));
      
        } catch (NoSuchBeanDefinitionException ignore) {
      
        }
      
        // Don't save _class to mongo
      
        mappingConverter.setTypeMapper(new DefaultMongoTypeMapper(null));
      
        return mappingConverter;
      
    }
    ```

- 游记评论

  

  

  ```java
  /**
  
   * 游记评论
  
   */
  
  @Setter
  
  @Getter
  
  @Document("travel_comment")
  
  public class TravelComment implements Serializable {
  
  public static final int TRAVLE_COMMENT_TYPE_COMMENT = 0; //普通评论
    
  public static final int TRAVLE_COMMENT_TYPE = 1; //评论的评论
    
  @Id
    
  private String id;  //id
    
  private String travelId;  //游记id
    
  private String travelTitle; //游记标题
    
  private String userId;    //用户id
    
  private String nickname; //用户名
    
  private String city;
    
  private int level;
    
  private String headImgUrl;   // 用户头像
    
  private int type = TRAVLE_COMMENT_TYPE_COMMENT; //评论类别
    
  private Date createTime; //创建时间
    
  private String content;  //评论内容
    
  private TravelComment refComment;  //关联的评论
  
  }
  ```

  - 表情处理

- 【拓展】游记首页里面最新游记评论动态(前10个)

### 后端【拓展】

- 攻略评论管理
- 游记评论管理

### 用户对象注入

1:定义参数注解

```java
/**

*定义userInfo 参数注入注解

 */

@Target({ElementType.PARAMETER})

@Retention(RetentionPolicy.RUNTIME)

public @interface UserParam {

}
```





2:定义参数解析器





```java
public class UserInfoArgumentResolver implements HandlerMethodArgumentResolver {

@Reference

private IUserInfoRedisService userInfoRedisService;

@Override

public boolean supportsParameter(MethodParameter methodParameter) {

    return methodParameter.hasParameterAnnotation(UserParam.class) &&methodParameter.getParameterType() == UserInfo.class;

}

@Override

public Object resolveArgument(MethodParameter methodParameter,

                              ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest,

                              WebDataBinderFactory webDataBinderFactory) throws Exception {

    HttpServletRequest request = nativeWebRequest.getNativeRequest(HttpServletRequest.class);

    Cookie cookie = CookieUtil.getCookie(request, UserInfoKeyPrefix.USER_LOGIN_COOKIE_NAME);

    if(cookie != null){

        return userInfoRedisService.getUserInfoByToken(cookie.getValue());

    }

    return null;

}

}
```



3:使用参数解析器

//添加自定义参数解析器

```java
@Override

public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {

    resolvers.add(userInfoArgumentResolver());

}
```



```java
@Bean

public UserInfoArgumentResolver userInfoArgumentResolver(){

    return new UserInfoArgumentResolver();

}
```

## 数据统计

浏览/点赞/评论/分享/收藏数

### 设计与分析

- 统计对象

  

  ```java
  /**
  
  *攻略redis中统计数据
  
  *运用模块：
  
  *1：数据统计(回复，点赞，收藏，分享，查看)
  
   */
  
  @Getter
  
  @Setter
  
  public class StrategyStatisVO implements Serializable {
  
  private Long strategyId;  //攻略id
  
  private int viewnum;  //点击数
  
  private int replynum;  //攻略评论数
  
  private int favornum; //收藏数
  
  private int sharenum; //分享数
  
  private int thumbsupnum; //点赞个数
  
  }
  ```


### 代码实现

- 逻辑实现

	- 阅读数
	- 回复数
	- 收藏数
	- 点赞数
	- 分享数[拓展]

- 初始化redis数据

  - spring事件监听

    https://www.jianshu.com/p/06e5b40400af

    Spring框架中有哪些不同类型的事件？

    

    Spring 提供了以下5种标准的事件：

    （1）上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。

    （2）上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。

    （3）上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。

    （4）上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。

    （5）请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。

    

    如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。

    

    

    定义监听器，实现接口：ApplicationListener<ContextRefreshedEvent>

    @Component

    public class RedisDataInitListener implements ApplicationListener<ContextRefreshedEvent>  {

    

    ```java
    @Reference
    private IStrategyDetailService strategyDetailService;
    
    @Reference
    private IStrategyStatisRedisService strategyStatisRedisService;
    
    @Override
      
    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {
      
        System.out.println("---------------begin---------------------");
      
        List<StrategyDetail> list = strategyDetailService.list();
      
        StrategyStatisVO vo = null;
      
        for (StrategyDetail detail : list) {
      
            vo = new StrategyStatisVO();
      
            vo.setIsabroad(detail.isIsabroad());
      
            vo.setDestId(detail.getDest().getId());
      
            vo.setDestName(detail.getDest().getName());
      
            vo.setTitle(detail.getTitle());
      
            vo.setStrateyId(detail.getId());
      
            vo.setThumbsupnum(detail.getThumbsupnum());
      
            vo.setSharenum(detail.getSharenum());
      
            vo.setReplynum(detail.getReplynum());
      
            vo.setFavornum(detail.getStartnum());
      
            vo.setViewnum(detail.getClicknum());
      
            strategyStatisRedisService.setStatisVO(StrategyStatisKeyPrefix.STRATEGY_STATIS_VO, detail.getId(), vo);
      
        }
      
        System.out.println("---------------end---------------------");
      
    }
    
    }
    ```
    
    

    

    

    

    

- redis数据落地

  - spring定时器

    https://blog.csdn.net/longzhongxiaoniao/article/details/86182075

    

    

    https://www.cnblogs.com/javahr/p/8318728.html

    http://cron.qqe2.com/

    

    1:定义任务执行器

    RedisDataPersistenceJob

    

    

    

    ```java
    /**
    
    *redis数据持久化
    
     */
    
    @Component
    
    public class RedisDataPersistenceJob {
    
    @Reference
    
    private IStrategyDetailService strategyDetailService;
    
    @Reference
    
    private IStrategyStatisRedisService strategyStatisRedisService;
    
    //秒 分 小时 月份中的日期 月份 星期中的日期 年份
    
    //0 0 0 1/1 * ? 
    
    @Scheduled(cron="0/10 * * * * ?")
    
    public void redisDataPersistence(){
    
        String keyPattern = StrategyStatisKeyPrefix.STRATEGY_STATIS_VO.getPrefix() + ":*";
    
        List<StrategyStatisVO> list = strategyStatisRedisService.getStatisVOs(keyPattern);
    
        for (StrategyStatisVO vo : list) {
    
            strategyDetailService.updateStatis(vo);
    
        }
    
    }
    
    }
    ```

    

    

    2：启动springboot 定时任务支持

    

    @EnableScheduling

    public class MgrSite {

    ....

    }

### 游记的数据统计【拓展】

### 用户收藏持久化【拓展】



用户收藏持久化【拓展】

传统

1：设计中间表保存用户id跟攻略id



## 网站首页

### banner



    package cn.wolfcode.wolf2w.domain;
    
    
    
    import com.alibaba.fastjson.JSON;
    
    import com.baomidou.mybatisplus.annotation.TableName;
    
    import lombok.Getter;
    
    import lombok.Setter;
    
    
    
    
    
    import java.util.HashMap;
    
    import java.util.Map;
    
    
    
    /**
    
    *游记推荐
    
     */
    
    @Setter
    
    @Getter
    
    @TableName("banner")
    
    public class Banner  extends BaseDomain {
    
    public static final int STATE_NORMAL = 0;   //正常
    
    public static final int STATE_DISABLE = 1;  //禁用
    
    public static final int TYPE_TRAVEL = 1;  //游记
    
    public static final int TYPE_STRATEGY = 2;  //攻略
    
    private Long refid;  //关联id
    
    private String title;  //标题
    
    private String subtitle; //副标题
    
    private String coverUrl; //封面
    
    private Integer state = STATE_NORMAL; //状态
    
    private Integer seq; //排序
    
    private Integer type;
    
    public String getJsonString(){
    
        Map<String, Object> map = new HashMap<>();
    
        map.put("id",id);
    
        map.put("title",title);
    
        map.put("subtitle",subtitle);
    
        map.put("coverUrl",coverUrl);
    
        map.put("state",state);
    
        map.put("seq",seq);
    
        map.put("refid",refid);
    
        map.put("type",type);
    
        return JSON.toJSONString(map);
    
    }
    
    public String getStateDisplay(){
    
        return state == STATE_NORMAL?"正常":"禁用";
    
    }
    
    public String getTypeDisplay(){
    
        return type == TYPE_STRATEGY?"攻略":"游记";
    
    }
    
    }



- 后端

	- 列表
	- 添加
	- 编辑

### elasticsearch使用方式

- 方式1：数据独立存储与独立搜索

  mysql 数据同步到es中， 搜索时仅仅搜索es数据

- 方式2：条件搜索与主键查询

  搜索时搜索es数据得到数据的主键(id), 再通过主键查询mysql数据

### 数据初始化

package cn.wolfcode.wolf2w.controller;





import cn.wolfcode.wolf2w.domain.Destination;

import cn.wolfcode.wolf2w.domain.Strategy;

import cn.wolfcode.wolf2w.domain.Travel;

import cn.wolfcode.wolf2w.domain.UserInfo;

import cn.wolfcode.wolf2w.search.domain.DestinationEs;

import cn.wolfcode.wolf2w.search.domain.StrategyEs;

import cn.wolfcode.wolf2w.search.domain.TravelEs;

import cn.wolfcode.wolf2w.search.domain.UserInfoEs;

import cn.wolfcode.wolf2w.search.service.IDestinationEsService;

import cn.wolfcode.wolf2w.search.service.IStrategyEsService;

import cn.wolfcode.wolf2w.search.service.ITravelEsService;

import cn.wolfcode.wolf2w.search.service.IUserInfoEsService;

import cn.wolfcode.wolf2w.service.IDestinationService;

import cn.wolfcode.wolf2w.service.IStrategyService;

import cn.wolfcode.wolf2w.service.ITravelService;

import cn.wolfcode.wolf2w.service.IUserInfoService;

import org.springframework.beans.BeanUtils;

import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.web.bind.annotation.GetMapping;



import org.springframework.web.bind.annotation.RestController;

import springfox.documentation.annotations.ApiIgnore;



import java.util.List;

@ApiIgnore

@RestController

public class DataController {

    //es服务
    
    @Autowired
    
    private IDestinationEsService destinationEsService;
    
    @Autowired
    
    private IStrategyEsService strategyEsService;
    
    @Autowired
    
    private ITravelEsService travelEsService;
    
    @Autowired
    
    private IUserInfoEsService userInfoEsService;



    //mysql服务
    
    @Autowired
    
    private IDestinationService destinationService;
    
    @Autowired
    
    private IStrategyService strategyService;
    
    @Autowired
    
    private ITravelService travelService;
    
    @Autowired
    
    private IUserInfoService userInfoService;



    @ApiIgnore
    
    @GetMapping("/dataInit")
    
    public Object dataInit(){
    
        //攻略
    
        List<Strategy> sts = strategyService.list();
    
        for (Strategy st : sts) {
    
            StrategyEs es = new StrategyEs();
    
            BeanUtils.copyProperties(st, es);
    
            strategyEsService.save(es);
    
        }
    
        //游记
    
       List<Travel> ts = travelService.list();
    
        for (Travel t : ts) {
    
            TravelEs es = new TravelEs();
    
            BeanUtils.copyProperties(t, es);
    
            travelEsService.save(es);
    
        }
    
        List<UserInfo> uf = userInfoService.list();
    
        for (UserInfo u : uf) {
    
            UserInfoEs es = new UserInfoEs();
    
            BeanUtils.copyProperties(u, es);
    
            userInfoEsService.save(es);
    
        }
    
        //目的地
    
        List<Destination> dests = destinationService.list();
    
        for (Destination d : dests) {
    
            DestinationEs es = new DestinationEs();
    
            BeanUtils.copyProperties(d, es);
    
            destinationEsService.save(es);
    
        }
    
        return "ok";
    
    }

}



- 目的地

  package cn.wolfcode.wolf2w.search.domain;

  

  import lombok.Getter;

  import lombok.Setter;

  import org.springframework.data.annotation.Id;

  import org.springframework.data.elasticsearch.annotations.Document;

  import org.springframework.data.elasticsearch.annotations.Field;

  import org.springframework.data.elasticsearch.annotations.FieldType;

  

  import java.io.Serializable;

  

  /**

   * 目的地搜索对象

   */

  @Getter

  @Setter

  @Document(indexName="destination")

  public class DestinationEs implements Serializable {

      public static final String INDEX_NAME = "destination";
        
      @Id
        
      //@Field 每个文档的字段配置（类型、是否分词、是否存储、分词器 ）
        
      @Field(store=true, index = false,type = FieldType.Long)
        
      private Long id;  //攻略id
        
      @Field(index=true,store=true,type = FieldType.Keyword)
        
      private String name;
        
      @Field(index=true,analyzer="ik_max_word",store=true,searchAnalyzer="ik_max_word",type = FieldType.Text)
        
      private String info;

  }

- 攻略

  package cn.wolfcode.wolf2w.search.domain;

  

  import lombok.Getter;

  import lombok.Setter;

  import org.springframework.data.annotation.Id;

  import org.springframework.data.elasticsearch.annotations.Document;

  import org.springframework.data.elasticsearch.annotations.Field;

  import org.springframework.data.elasticsearch.annotations.FieldType;

  

  import java.io.Serializable;

  

  /**

   * 攻略搜索对象

   */

  @Getter

  @Setter

  @Document(indexName="strategy")

  public class StrategyEs implements Serializable {

  

      public static final String INDEX_NAME = "strategy";

  

      //@Field 每个文档的字段配置（类型、是否分词、是否存储、分词器 ）
        
      @Id
        
      @Field(store=true, index = false,type = FieldType.Long)
        
      private Long id;  //攻略id
        
      @Field(index=true,analyzer="ik_max_word",store=true,searchAnalyzer="ik_max_word",type = FieldType.Text)
        
      private String title;  //攻略标题
        
      @Field(index=true,analyzer="ik_max_word",store=true,searchAnalyzer="ik_max_word",type = FieldType.Text)
        
      private String subTitle;  //攻略标题
        
      @Field(index=true,analyzer="ik_max_word",store=true,searchAnalyzer="ik_max_word",type = FieldType.Text)
        
      private String summary; //攻略简介

  }

- 游记

  package cn.wolfcode.wolf2w.search.domain;

  

  import lombok.Getter;

  import lombok.Setter;

  import org.springframework.data.annotation.Id;

  import org.springframework.data.elasticsearch.annotations.Document;

  import org.springframework.data.elasticsearch.annotations.Field;

  import org.springframework.data.elasticsearch.annotations.FieldType;

  

  import java.io.Serializable;

  

  /**

   * 游记搜索对象

   */

  @Getter

  @Setter

  @Document(indexName="travel")

  public class TravelEs implements Serializable {

      public static final String INDEX_NAME = "travel";
        
      //@Field 每个文档的字段配置（类型、是否分词、是否存储、分词器 ）
        
      @Id
        
      @Field(store=true, index = false,type = FieldType.Keyword)
        
      private Long id;  //游记id
        
      @Field(index=true,analyzer="ik_max_word",store=true,searchAnalyzer="ik_max_word",type = FieldType.Text)
        
      private String title;  //游记标题
        
      @Field(index=true,analyzer="ik_max_word",store=true,searchAnalyzer="ik_max_word",type = FieldType.Text)
        
      private String summary; //游记简介

  }

- 用户

  package cn.wolfcode.wolf2w.search.domain;

  

  import lombok.Getter;

  import lombok.Setter;

  import org.springframework.data.annotation.Id;

  import org.springframework.data.elasticsearch.annotations.Document;

  import org.springframework.data.elasticsearch.annotations.Field;

  import org.springframework.data.elasticsearch.annotations.FieldType;

  

  import java.io.Serializable;

  

  /**

   * 用户搜索对象

   */

  @Getter

  @Setter

  @Document(indexName="userinfo")

  public class UserInfoEs implements Serializable {

      public static final String INDEX_NAME = "userinfo";
      
      @Id
      
      //@Field 每个文档的字段配置（类型、是否分词、是否存储、分词器 ）
      
      @Field(store=true, index = false,type = FieldType.Long)
      
      private Long id;  //用户id
      
      @Field(index=true,analyzer="ik_max_word",store=true,searchAnalyzer="ik_max_word",type = FieldType.Text)
      
      private String nickname;
      
      @Field(index=true,store=true,type = FieldType.Keyword)
      
      private String city;
      
      @Field(index=true,analyzer="ik_max_word",store=true,searchAnalyzer="ik_max_word",type = FieldType.Text)
      
      private String info;

  }

### 关键字搜索

@GetMapping("/q")

    public Object search(SearchQueryObject qo){
    
        switch (qo.getType()){
    
            case  SearchQueryObject.TYPE_DEST :
    
                //目的地
    
                return searchDest(qo);
    
            case  SearchQueryObject.TYPE_STRATEGY :
    
                //攻略
    
                return searchStrategy(qo);
    
            case  SearchQueryObject.TYPE_TRAVEL :
    
                //游记
    
                return searchTravel(qo);
    
            case  SearchQueryObject.TYPE_USER :
    
                //用户
    
                return searchUser(qo);
    
            default:
    
                //全部
    
                return searchAll(qo);
    
        }
    
    }

- 目的地搜索

  //目的地

      private Object searchDest(SearchQueryObject qo) {
        
          //1:通过关键字查询目的地是否存在
        
          Destination dest = destinationService.getByName(qo.getKeyword());
        
          SearchResultVO data = new SearchResultVO();
        
          if(dest != null){
        
              //2:存在: 查询指定目的地下的攻略, 游记, 用户 约定前5篇
        
              List<Strategy> sts = strategyService.getByDestName(qo.getKeyword());
        
              data.setTotal(sts.size() + data.getTotal());
        
              if(sts.size() > 5){
        
                  sts = sts.subList(0,5);
        
              }
        
              List<Travel> ts = travelService.getByDestName(qo.getKeyword());
        
              data.setTotal(ts.size() + data.getTotal());
        
              if(ts.size() > 5){
        
                  ts = ts.subList(0,5);
        
              }
        
              List<UserInfo> us = userInfoService.getByCity(qo.getKeyword());
        
              data.setTotal(us.size() + data.getTotal());
        
              if(us.size() > 5){
        
                  us = us.subList(0,5);
        
              }
        
              data.setUsers(us);
        
              data.setStrategys(sts);
        
              data.setTravels(ts);
        
          }
        
          //3:不存在: 提示不存在
        
          return JsonResult.success(new ParamMap().put("result", data).put("dest", dest).put("qo", qo));
        
      }

	- 数据封装对象

	  package cn.wolfcode.wolf2w.search.vo;

	  

	  import cn.wolfcode.wolf2w.domain.Destination;

	  import cn.wolfcode.wolf2w.domain.Strategy;

	  import cn.wolfcode.wolf2w.domain.Travel;

	  import cn.wolfcode.wolf2w.domain.UserInfo;

	  import lombok.Getter;

	  import lombok.Setter;

	  

	  import java.io.Serializable;

	  import java.util.ArrayList;

	  import java.util.List;

	  

	  @Setter

	  @Getter

	  public class SearchResultVO implements Serializable{

	  

	  

	      private Long total = 0L;

	  

	      private List<Strategy> strategys = new ArrayList<>();
          
	      private List<Travel> travels = new ArrayList<>();
          
	      private List<UserInfo> users = new ArrayList<>();
          
	      private List<Destination> dests = new ArrayList<>();

	  

	  }

	  

- 攻略搜索

  //攻略

      private Object searchStrategy(SearchQueryObject qo) {
        
          Page<Strategy> page = searchService.searchWithHighlight(StrategyEs.INDEX_NAME, StrategyEs.TYPE_NAME, Strategy.class, qo,
        
                  "title", "subTitle", "summary");
        
          return JsonResult.success(new ParamMap().put("page", page).put("qo", qo));
        
      }

- 游记搜索

  //游记

      private Object searchTravel(SearchQueryObject qo) {
        
          Page<Travel> page = searchService.searchWithHighlight(TravelEs.INDEX_NAME, TravelEs.TYPE_NAME, Travel.class, qo,
        
                  "title", "summary");

  

          return JsonResult.success(new ParamMap().put("page", page).put("qo", qo));
        
      }

- 用户搜索

   //用户

      private Object searchUser(SearchQueryObject qo) {

          Page<UserInfo> page = searchService.searchWithHighlight(UserInfoEs.INDEX_NAME, UserInfoEs.TYPE_NAME, UserInfo.class, qo,
        
                  "city", "info");
        
          return JsonResult.success(new ParamMap().put("page", page).put("qo", qo));

      }

- 全部搜索

  //所有

      private Object searchAll(SearchQueryObject qo) {

  

          Page<Strategy> sts = searchService.searchWithHighlight(StrategyEs.INDEX_NAME, StrategyEs.TYPE_NAME, Strategy.class, qo,
      
                  "title", "subTitle", "summary");
      
          Page<Travel> ts = searchService.searchWithHighlight(TravelEs.INDEX_NAME, TravelEs.TYPE_NAME, Travel.class, qo,
      
                  "title", "summary");
      
          Page<UserInfo> us = searchService.searchWithHighlight(UserInfoEs.INDEX_NAME, UserInfoEs.TYPE_NAME, UserInfo.class, qo,
      
                  "city", "info");
      
          Page<Destination> ds = searchService.searchWithHighlight(DestinationEs.INDEX_NAME, DestinationEs.TYPE_NAME, Destination.class, qo,
      
                  "name", "info");

  

  

          SearchResultVO vo = new SearchResultVO();

  

          vo.setDests(ds.getContent());
      
          vo.setStrategys(sts.getContent());
      
          vo.setTravels(ts.getContent());
      
          vo.setUsers(us.getContent());

  

          vo.setTotal(sts.getTotalElements() + ts.getNumberOfElements() + us.getTotalElements() + ds.getTotalElements());

  

          return JsonResult.success(new ParamMap().put("result", vo).put("qo", qo));
      
      }

### 方法解析

- 泛型方法定义
- 高亮显示

  package cn.wolfcode.wolf2w.search.service.impl;

  

  import cn.wolfcode.wolf2w.domain.Destination;

  import cn.wolfcode.wolf2w.domain.Strategy;

  import cn.wolfcode.wolf2w.domain.Travel;

  import cn.wolfcode.wolf2w.domain.UserInfo;

  import cn.wolfcode.wolf2w.search.query.SearchQueryObject;

  import cn.wolfcode.wolf2w.search.service.ISearchService;

  import cn.wolfcode.wolf2w.service.IDestinationService;

  import cn.wolfcode.wolf2w.service.IStrategyService;

  import cn.wolfcode.wolf2w.service.ITravelService;

  import cn.wolfcode.wolf2w.service.IUserInfoService;

  import org.apache.commons.beanutils.BeanUtils;

  import org.elasticsearch.action.search.SearchRequest;

  import org.elasticsearch.common.text.Text;

  import org.elasticsearch.index.query.MultiMatchQueryBuilder;

  import org.elasticsearch.index.query.QueryBuilders;

  import org.elasticsearch.search.builder.SearchSourceBuilder;

  import org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder;

  import org.elasticsearch.search.fetch.subphase.highlight.HighlightField;

  import org.springframework.beans.factory.annotation.Autowired;

  import org.springframework.data.domain.*;

  import org.springframework.data.elasticsearch.core.ElasticsearchRestTemplate;

  import org.springframework.data.elasticsearch.core.SearchHit;

  import org.springframework.data.elasticsearch.core.SearchHits;

  import org.springframework.data.elasticsearch.core.mapping.IndexCoordinates;

  import org.springframework.data.elasticsearch.core.query.NativeSearchQuery;

  import org.springframework.data.elasticsearch.core.query.NativeSearchQueryBuilder;

  import org.springframework.stereotype.Service;

  import org.springframework.util.StringUtils;

  

  import java.lang.reflect.InvocationTargetException;

  import java.util.ArrayList;

  import java.util.HashMap;

  import java.util.List;

  import java.util.Map;

  

  @Service

  public class SearchServiceImpl implements ISearchService {

      @Autowired
      
      private IUserInfoService userInfoService;
      
      @Autowired
      
      private IStrategyService strategyService;
      
      @Autowired
      
      private ITravelService travelService;
      
      @Autowired
      
      private IDestinationService destinationService;

  

      @Autowired
      
      private ElasticsearchRestTemplate template;

  

      //关键字: keyword = 广州
      
      //以title为例:
      
      //原始匹配: "有娃必看,广州长隆野生动物园全攻略"
      
      //高亮显示后:"有娃必看,<span style="color:red;">广州</span>长隆野生动物园全攻略"
      
      @Override
      
      public <T> Page<T> searchWithHighlight(String index, Class<T> clz, SearchQueryObject qo, String... fields) {
      
          SearchRequest searchRequest = new SearchRequest(index);
      
          SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
      
          //高亮显示
      
          /*"query":{
      
              "multi_match": {
      
                  "query": "广州",
      
                  "fields": ["title","subTitle","summary"]
      
              }
      
          },*/
      
          MultiMatchQueryBuilder queryBuilder = QueryBuilders.multiMatchQuery(qo.getKeyword(),fields);
      
          HighlightBuilder highlightBuilder = new HighlightBuilder(); // 生成高亮查询器
      
          for (String field: fields) {
      
              highlightBuilder.field(field);// 高亮查询字段
      
          }
      
          highlightBuilder.requireFieldMatch(false); // 如果要多个字段高亮,这项要为false
      
          highlightBuilder.preTags("<span style='color:red'>"); // 高亮设置
      
          highlightBuilder.postTags("</span>");
      
          highlightBuilder.fragmentSize(800000); // 最大高亮分片数
      
          highlightBuilder.numOfFragments(0); // 从第一个分片获取高亮片段
      
          /**
      
           "from": 0,
      
           "size":3,
      
           */
      
          Pageable pageable = PageRequest.of(qo.getCurrentPage() - 1, qo.getPageSize(),
      
                  Sort.Direction.ASC, "_id");// 设置分页参数
      
          NativeSearchQuery searchQuery = new NativeSearchQueryBuilder()
      
                  .withQuery(queryBuilder) // match查询
      
                  .withPageable(pageable).withHighlightBuilder(highlightBuilder) // 设置高亮
      
                  .build();

  

  

          SearchHits<T> searchHits = template.search(searchQuery, clz,IndexCoordinates.of(index));
      
          List<T> list = new ArrayList();
      
          for (SearchHit<T> searchHit : searchHits) { // 获取搜索到的数据
      
              T content = this.parseType(clz, searchHit.getId());

  

              // 处理高亮
      
              Map<String, String> map = highlightFieldsCopy(searchHit.getHighlightFields(), fields);

  

              //1：spring 框架中BeanUtils 类，如果是map集合是无法进行属性复制
      
              //   copyProperties(源， 目标)
      
              //2: apache  BeanUtils 类 可以进map集合属性复制
      
              //   copyProperties(目标， 源)
      
              try {
      
                  BeanUtils.copyProperties(content, map);
      
              } catch (IllegalAccessException e) {
      
                  e.printStackTrace();
      
              } catch (InvocationTargetException e) {
      
                  e.printStackTrace();
      
              }
      
              list.add(content);
      
          }
      
          Page page = new PageImpl(list, pageable, searchHits.getTotalHits());
      
          return  page;
      
      }

  

  

      private <T> T parseType(Class<T> clz, String id){
      
          Long lId = 0L;
      
          if(StringUtils.hasLength(id)){
      
              lId = Long.valueOf(id);
      
          }
      
          T t = null;
      
          if(clz == UserInfo.class){
      
              t = (T) userInfoService.getById(lId);
      
          }else if(clz == Travel.class){
      
              t = (T) travelService.getById(lId);

  

          }else if(clz == Strategy.class){
      
              t = (T) strategyService.getById(lId);
      
          }else if(clz == Destination.class){
      
              t = (T) destinationService.getById(lId);
      
          }else{
      
              t= null;
      
          }
      
          return t;
      
      }

  

  

  

      //fields: title subTitle summary
      
      private Map<String, String>   highlightFieldsCopy(Map<String, List<String>> map, String ...fields){
      
          Map<String, String> mm = new HashMap<>();
      
          //title:  "有娃必看，<span style='color:red;'>广州</span>长隆野生动物园全攻略"
      
          //subTitle: "<span style='color:red;'>广州</span>长隆野生动物园"
      
          //summary: "如果要说动物园，楼主强烈推荐带娃去<span style='color:red;'>广州</span>长隆野生动物园
      
          //title subTitle summary
      
          for (String field : fields) {
      
              List<String> hfs = map.get(field);
      
              if (hfs != null && !hfs.isEmpty()) {
      
                  //获取高亮显示字段值, 因为是一个数组, 所有使用string拼接

  

                  StringBuilder sb = new StringBuilder();
      
                  for (String hf : hfs) {
      
                      sb.append(hf);
      
                  }
      
                  mm.put(field, sb.toString());  //使用map对象将所有能替换字段先缓存, 后续统一替换
      
              }
      
          }
      
          return mm;
      
      }

  

  

  

  }

  

### 数据同步与更新【拓展】

数据同步问题







使用消息中间件

kafka/各类MQ

## 项目相关

### 接口文档

- 作用

  1，api一定需要开发文档配合，移动端只需要根据开发文档进行开发即可；

  2，传统的开发文档问题：格式随意，更新不及时；

  

  

  

  https://www.jianshu.com/p/d7b13670e0eb

  

  

  

  

  

  

- ShowDoc

  https://www.showdoc.cc/

- swagger2

  Swagger能够根据代码中的注解自动生成api文档，并且提供测试接口；

	- 依赖

	  <dependency>

	              <groupId>io.springfox</groupId>
	        
	              <artifactId>springfox-swagger2</artifactId>
	        
	              <version>2.9.2</version>
	        
	          </dependency>

	  

	          <dependency>
	        
	              <groupId>io.springfox</groupId>
	        
	              <artifactId>springfox-swagger-ui</artifactId>
	        
	              <version>2.9.2</version>
	        
	          </dependency>

	- 配置文件

	  package cn.wolfcode.luowowo.swagger2;

	  

	  import org.springframework.context.annotation.Bean;

	  import org.springframework.context.annotation.Configuration;

	  import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;

	  import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;

	  import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

	  import springfox.documentation.builders.ApiInfoBuilder;

	  import springfox.documentation.builders.ParameterBuilder;

	  import springfox.documentation.builders.PathSelectors;

	  import springfox.documentation.builders.RequestHandlerSelectors;

	  import springfox.documentation.schema.ModelRef;

	  import springfox.documentation.service.ApiInfo;

	  import springfox.documentation.service.Parameter;

	  import springfox.documentation.spi.DocumentationType;

	  import springfox.documentation.spring.web.plugins.Docket;

	  import springfox.documentation.swagger2.annotations.EnableSwagger2;

	  

	  import java.util.ArrayList;

	  import java.util.List;

	  

	  @Configuration

	  @EnableSwagger2

	  public class SwaggerConfig implements WebMvcConfigurer {

	  

	      @Bean
	        
	      public Docket productApi() {

	  

	          //添加head参数start
	        
	          ParameterBuilder tokenPar = new ParameterBuilder();
	        
	          List<Parameter> pars = new ArrayList<Parameter>();
	        
	          tokenPar.name("token").description("令牌").modelRef(new ModelRef("string")).parameterType("header").required(false).build();
	        
	          pars.add(tokenPar.build());

	  

	          return new Docket(DocumentationType.SWAGGER_2).select()
	        
	                  // 扫描的包路径
	        
	                  .apis(RequestHandlerSelectors.basePackage("cn.wolfcode.luowowo.controller"))
	        
	                  // 定义要生成文档的Api的url路径规则
	        
	                  .paths(PathSelectors.any())
	        
	                  .build()
	        
	                  .globalOperationParameters(pars)
	        
	                  // 设置swagger-ui.html页面上的一些元素信息。
	        
	                  .apiInfo(metaData());
	        
	      }

	  

	      private ApiInfo metaData() {
	        
	          return new ApiInfoBuilder()
	        
	                  // 标题
	        
	                  .title("SpringBoot集成Swagger2")
	        
	                  // 描述
	        
	                  .description("骡窝窝项目接口文档")
	        
	                  // 文档版本
	        
	                  .version("1.0.0")
	        
	                  .license("Apache License Version 2.0")
	        
	                  .licenseUrl("https://www.apache.org/licenses/LICENSE-2.0")
	        
	                  .build();
	        
	      }

	  

	      //ui页面
	        
	      @Override
	        
	      public void addResourceHandlers(ResourceHandlerRegistry registry) {
	        
	          registry.addResourceHandler("swagger-ui.html")
	        
	                  .addResourceLocations("classpath:/META-INF/resources/");

	  

	          registry.addResourceHandler("/webjars/**")
	        
	                  .addResourceLocations("classpath:/META-INF/resources/webjars/");
	        
	      }

	  }

	- 访问

	  http://localhost:8080/swagger-ui.html

	- 常见标签

		- @Api/@ApiOperation

		  @Api：用在类上，说明该类的作用
		  @Api(value = "用户资源",description = "用户资源控制器")
		  
		  @ApiOperation：用在方法上，说明方法的作用
		  @ApiOperation(value = "注册功能",notes = "其实就是新增用户")

		- @ApiImplicitParams/@ApiImplicitParam

		  @ApiImplicitParams：用在方法上包含一组参数说明
		  @ApiImplicitParam：用在@ApiImplicitParams注解中，指定一个请求参数的各个方面
		  paramType：参数放在哪个地方
		  header-->请求参数的获取
		  query-->请求参数的获取
		  path-->请求参数的获取（用于restful接口）：
		  body-->请求实体中
		  
		  
		  @ApiImplicitParams({
		              @ApiImplicitParam(value = "昵称",name = "nickName",dataType = "String",required = true),
		              @ApiImplicitParam(value = "邮箱",name = "email",dataType = "String",required = true),
		              @ApiImplicitParam(value = "密码",name = "password",dataType = "String",required = true)
		      })

		- @ApiModel/@ApiModelProperty

		  @ApiModel：描述一个Model的信息

		  （这种一般用在post创建的时候，使用@RequestBody这样的场景，请求参数无法使用@ApiImplicitParam注解进行描述的时候）

		  @ApiModelProperty：描述一个model的属性

		  

		  

		  @ApiModel(value="用户",description="平台注册用户模型")

		  @ApiModelProperty(value="昵称",name="nickName",dataType = "String",required = true)

		  

		- @ApiResponses/@ApiResponse

		  @ApiResponses：用于表示一组响应
		  @ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息(200相应不写在这里面)
		  		code：数字，例如400
		  		message：信息，例如"请求参数没填好"
		  		response：抛出的异常类
		  
		  @ApiResponses({
		  	@ApiResponse(code=200,message="用户注册成功")
		  })

		- @ApiIgnore

		  有些接口不想显示，就贴上去，可以贴在类上，也可以贴在方法上。

### 接口安全

api接口分类:

   1>公共接口：你查快递，你查天气预报，你查飞机，火车班次等，这些都是有公共的接口



   2>私密接口：需要登录访问或者公司内部接口





接口安全要求：

1.防伪装攻击（案例：在公共网络环境中，第三方 有意或恶意 的调用我们的接口）：接口防刷



2.防篡改攻击（案例：在公共网络环境中，请求头/查询字符串/内容 在传输过程被修改）：接口防篡改(签名机制)



3.防重放攻击（案例：在公共网络环境中，请求被截获，稍后被重放或多次重放）：接口时效性



4.防数据信息泄漏（案例：截获用户登录请求，截获到账号、密码等）：接口加密(https/对称加解密)

- 接口防刷

  思路：

  

  1：设计一个redis临时key， 有效时间是1分钟，1分钟内只允许10访问

       key>   url ： ip
        
       value>访问的次数

  

  2：设置拦截器，拦截需要防刷的接口url

  

  3：拦截逻辑

         3.1>拦截url，拼接key查询redis中是否存在
        
         3.2>如果不存在setnx  url:ip  10
        
         3.3>如果存在derc  url:ip 
        
         3.4>如果次数减到0，拦截返回：请勿频繁访问
        
         3.5>其他情况直接放行。

  

  ----------------------------------------------------------------------------------------------

  拦截器

  /**

   * 防刷拦截器

   */

  public class BrushProofInterceptor implements HandlerInterceptor {

      @Autowired
        
      private ISecurityRedisService securityRedisService;
        
      @Override
        
      public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
        
              throws Exception {

  

          if(!(handler instanceof HandlerMethod)){
        
              return  true;
        
          }

  

          //防刷验证
        
          String url = request.getRequestURI().substring(1);
        
          String ip = RequestUtil.getIPAddress();

  

          String key = RedisKeys.BRUSH_PROOF.join(url, ip);

  

          if(!securityRedisService.isAllowBrush(key)){
        
              response.setContentType("text/json;charset=UTF-8");
        
              response.getWriter().write(JSON.toJSONString(JsonResult.error(500, "请勿频繁访问","谢谢咯")));
        
              return false;
        
          }

  

          return true;
        
      }

  }

  

  

  redis服务

  @Service

  public class SecurityRedisServiceImpl implements ISecurityRedisService {

  

      @Autowired
        
      private StringRedisTemplate template;

  

  

      @Override
        
      public boolean isAllowBrush(String key) {
        
          //如果有不做 任何操作，如果没有添加
        
          template.opsForValue().setIfAbsent(key, "10", RedisKeys.BRUSH_PROOF.getTime(), TimeUnit.SECONDS);
        
          Long decrement = template.opsForValue().decrement(key);
        
          return decrement >= 0;
        
      }

  }

  

  

  拦截器配置

      @Bean
        
      public BrushProofInterceptor brushProofInterceptor(){
        
          return  new BrushProofInterceptor();
        
      }

  

   @Override

      public void addInterceptors(InterceptorRegistry registry) {
        
          registry.addInterceptor(checkLoginInterceptor())
        
                  .addPathPatterns("/**");

  

          //防刷
        
          registry.addInterceptor(brushProofInterceptor())
        
                  .addPathPatterns("/**");

  

      }

  

  

  

  

- 接口防篡改

  签名机制

  思路：

  

  1：前端传参数时，对参数的名进行字典排序，然后按照参数名的属性对参数值进行有序拼接

         比如：
        
         参数列表： c=参数1， f=参数2，  a=参数3，   b=参数4
        
         参数排名： a  b  c  f  
        
         参数值拼接：a=参数3&数4& c=参数1& f=参数2

  

  2：使用MD5对拼接参数值串进行加密得到参数签名sign_client

  

  

  3：将所有参数与sign一同发送到后端

  

  

  4：后端获取到所有参数， 按照同样的逻辑，MD5加密得到sign_server

         参数列表： c=参数1， f=参数2，  a=参数3，   b=参数4   sign_client
        
         参数排名： a  b  c  f  
        
         参数值拼接：a=参数3&数4& c=参数1& f=参数2

  

  5：对比sign_server 跟sign_client 2个签名是否一致， 一致表示参数没变篡改，否则提示参数被改，不合法。

  

  

  --------------------------------------------------------------------------------------------------------

  

  页面改动

  common.js

  

  

  //数据防篡改

  function getSignStr(param) {

      var sdic=Object.keys(param).sort();
        
      var signStr = "";
        
      for(var i in sdic){

  

          if(i == 0){
        
              signStr +=sdic[i]+"="+param[sdic[i]];
        
          }else{
        
              signStr +="&"+sdic[i]+"="+param[sdic[i]];
        
          }
        
      }

  

      console.log(hex_md5(signStr));
        
      return hex_md5(signStr).toUpperCase();

  }

  

  请求方法：ajaxRequest

  param.sign = getSignStr(param);

  

  

  操作有页面添加md5.js

   <script src="js/md5/md5.js"></script>

  

  后台：

  签名拦截器

  /**

   * 签名拦截(防篡改)

   */

  public class SignInterceptor implements HandlerInterceptor {

      @Override
        
      public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        
          if(!(handler instanceof HandlerMethod)){
        
              return  true;
        
          }

  

          //签名验证
        
          Map<String, String[]> map = request.getParameterMap();
        
          Set<String> keys = map.keySet();
        
          Map<String, Object> param = new HashMap<>();
        
          for (String s : map.keySet()) {
        
              if("sign".equalsIgnoreCase(s)){
        
                  continue;
        
              }
        
              param.put(s, arrayToString(map.get(s)));
        
          }
        
          String signatures = Md5Utils.signatures(param);
        
          String sign = request.getParameter("sign");
        
          if(sign == null || !sign.equalsIgnoreCase(signatures)){
        
              response.setContentType("text/json;charset=UTF-8");
        
              response.getWriter().write(JSON.toJSONString(new JsonResult(501,"签名校验失败","不好意思咯")));
        
              return false;
        
          }
        
          return true;
        
      }

  

  

      private String arrayToString(String [] array){

  

          StringBuilder sb = new StringBuilder(10);
        
          for (String s : array) {
        
              sb.append(s);
        
          }
        
          return sb.toString();
        
      }

  }

  

  配置拦截器

      @Bean
        
      public SignInterceptor signInterceptor(){
        
          return  new SignInterceptor();
        
      }

  

      @Override
        
      public void addInterceptors(InterceptorRegistry registry) {
        
          registry.addInterceptor(checkLoginInterceptor())
        
                  .addPathPatterns("/**");

  

          //防刷
        
          registry.addInterceptor(brushProofInterceptor())
        
                  .addPathPatterns("/**");

  

          //签名
        
          InterceptorRegistration it = registry.addInterceptor(signInterceptor())
        
                  .addPathPatterns("/**");

  

  

      }

  

  

  

  

  

  

  

  

  

- 接口时效性

  签名机制+有效时间

  思路：

  

  1：前端传参数时，对参数的名进行字典排序，然后按照参数名的属性对参数值进行有序拼接

         比如：
        
         参数列表： c=参数1， f=参数2，  a=参数3，   b=参数4  timestamp=188888
        
         参数排名： a  b  c  f   timestamp
        
         参数值拼接：a=参数3&数4& c=参数1& f=参数2&timestamp=188888

  2：使用MD5对拼接参数值串进行加密得到参数签名sign_client

  3：将所有参数与sign一同发送到后端

  4：后端获取到所有参数， 按照同样的逻辑，MD5加密得到sign_server

         参数列表： c=参数1， f=参数2，  a=参数3，   b=参数4   sign_client
        
         参数排名： a  b  c  f  
        
         参数值拼接：a=参数3&数4& c=参数1& f=参数2&timestamp=188888

  5：获取timestamp与当前时间对比是否在有效时间内， 比如1分钟， 在执行下一步， 不在，提示接口访问失效

  6：对比sign_server 跟sign_client 2个签名是否一致， 一致表示参数没变篡改，否则提示参数被改，不合法。

  

  

- 接口加密

  阿里云服务申请https加密证书

  

  https://www.cnblogs.com/shibaolong/p/9837247.html

## 问题

### MISCONF Redis is configured to save RDB snap

config set stop-writes-on-bgsave-error no

### netty jar包冲突

availableProcessors is already set to [4], rejecting [4]



 //解决netty冲突

        System.setProperty("es.set.netty.runtime.available.processors", "false");



